This file contains notes to self, just so that I don't forget them later on.

* Replace `print`s with `log`s.

  The idea is that logs will stay in the production code. They can be easily
  switched on and off by the verbosity level setting.

  Reference: `logging` module


* Refactor how the passes are applied to the list of tokens.

  There's got to be a way to simplify the logic instead of dealing with three
  lists and mangling their indices.


* Document the `_expand_body` function.

  Probably should also make it a method


* Review the `_Rule` class

  I think it needs a slightly more advanced processing in the constructor, not
  just setting the `special` flag.


* Refactor `_pattern_match` function

  This one is closely tied to the previous note.

  One way to rule this out would be to make `_Rule` a base class. Two new
  classes--`_RegularRule` and `_CyclingRule_`--will subclass from `_Rule`. Each
  of those subclasses will then have its own `pattern_match` method.


* Implement the 'a--xxx = {a} {1000} {x}' syntax in the RULES.

  To me at least, this looks like a cleaner way than writing 3 slightly varying
  rules.

  The rules for Spanish would become:

      RULES = """
      ab = {a0} y {b}
      axx = {a00} {x}
      a--xxx = {a} {1000} {x}
      (a)xxxxxx = {a} {x}
     """

* Implement the **literal string** with spaces for the `listparse` module

  A **literal string** is any sequence of characters, usually enclosed in single
  quotes ('). If there are no whitespace characters in the literal string, the
  quotes can be omitted.

  >>>
  IMPORTANT: this feature is not implemented in the syntax. However, you can
  emulate it by using a `matcher` with the following function:

    "mystr~find": lambda x: x == 'my literal string'
  <<<

* Implement the **regex literal** for the `listparse` module

  A **regex literal** is a string enclosed in single quotes with the letter 'r'
  immediately preceding the opening quote. Inside the quotes, the syntax defined
  in the Python's standard `re` module is used. To match a list element against
  a regex literal, `re.search` function is used. That is, if you want your
  regular expression to match the whole contents of an element, use the '^' and
  '$' anchors inside the regex literal.

  This too can be emulated with a matcher token.
